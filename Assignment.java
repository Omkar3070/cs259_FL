/* Assignment.java */
/* Generated By:JavaCC: Do not edit this line. Assignment.java */
import java.util.*;
import java.util.ArrayList;

public class Assignment implements AssignmentConstants {

    Boolean mainf = false;
    Map<String, LinkedList<funcObj>> tknTrack = new HashMap<String, LinkedList<funcObj>>();
    //Hashmap stores key-value pair which is used to check for divergence in
    //the program block, the function name as a String is the key and the value
    //is a Linked-List which stores all the function calls for the particular function
    static Map<String, LinkedList<Token>> diverMap = new HashMap<String, LinkedList<Token>>();
    //The diverList and tempDiver are Linked-List used to handle the function body
    //for filling the hash-map diverMap with values
    LinkedList<Token> diverList = new LinkedList<Token>();
    LinkedList<Token> tempDiver = new LinkedList<Token>();
    //The tknStore and temper are Linked-List used to handle the function body
    //for filling the hash-map tknTrack with values
    LinkedList<Token> tknStore = new LinkedList<Token>();
    LinkedList<Token> temper = new LinkedList<Token>();
    //forComp is used for storing functions to compare with function calls
    //when tryig to find circular function calls
    static ArrayList<Token> forComp = new ArrayList<Token>();
    //funcArr stores the function names as Strings.
    static ArrayList<String> funcArr = new ArrayList<String>();
    //jstArr stores the function names as Tokens
    static ArrayList<Token> jstArr = new ArrayList<Token>();
    //bodyFuncArr stores function calls
    ArrayList<String> bodyFuncArr = new ArrayList<String>();
    int counter = 0;

  public static void main(String args []) throws ParseException, TokenMgrError {

    Assignment parser = new Assignment(System.in);

    try{
    parser.start();
    }catch(ParseException e){   //All the parse errors are caught in this catch block

        if(e.currentToken.next.kind == 5 && e.expectedTokenSequences[0][0] == 13){
            System.out.println("FAIL");
            System.err.println(e.currentToken.beginLine);
            System.err.println("Missing Parameters");
            System.exit(0);
        }
        if(!e.currentToken.next.image.equals("DEF") && (e.expectedTokenSequences[0][0] == 0
            || e.expectedTokenSequences[0][0] == 7)){
            System.out.println("FAIL");
            System.err.println(e.currentToken.beginLine);
            System.err.println("Was expecting a DEF");
            System.exit(0);
        }
        if(e.currentToken.next.kind != 13 && (e.expectedTokenSequences[0][0] == 9
           || e.expectedTokenSequences[0][0] == 13)){
            System.out.println("FAIL");
            System.err.println(e.currentToken.beginLine);
            System.err.println("Parameter field contains characters other than lower-case letter(s).");
            System.exit(0);
        }
        if(e.currentToken.next.kind != 12 && (e.expectedTokenSequences[0][0] == 12
           || e.expectedTokenSequences[0][0] == 9 || e.expectedTokenSequences[0][0] == 11)){
            System.out.println("FAIL");
            System.err.println(e.currentToken.beginLine);
            System.err.println("Function name contains DEF or characters other than upper-case letter(s).");
            System.exit(0);
        }
        if(e.currentToken.next.kind != 5 && e.expectedTokenSequences[0][0] == 5){
            System.out.println("FAIL");
            System.err.println(e.currentToken.beginLine);
            System.err.println("Was expecting a { at line " + e.currentToken.beginLine + " column " + e.currentToken.next.beginColumn);
            System.exit(0);
        }
        if((e.currentToken.next.kind == 4 || e.currentToken.next.kind == 6) &&
            (e.expectedTokenSequences[0][0] == 12 || e.expectedTokenSequences[0][0] == 13 ||
            e.expectedTokenSequences[0][0] == 14)){
            System.out.println("FAIL");
            System.err.println(e.currentToken.beginLine);
            System.err.println("Function Body cannot be empty");
            System.exit(0);
        }
        if(e.currentToken.next.kind != 10 || e.expectedTokenSequences[0][0] == 10){
            System.out.println("FAIL");
            System.err.println(e.currentToken.beginLine);
            System.err.println("Missing a semicolon");
            System.exit(0);
        }
        else{
            System.out.println("FAIL");
            System.err.println(e.currentToken.beginLine);
            System.err.println("Use of Spaces is not correct");
            System.exit(0);
        }

    }catch(TokenMgrError q){    //All the lexical errors are caught in this catch block
        System.out.println("FAIL");
        System.err.println("Invalid charachter used");
        System.exit(0);
    }
    System.out.println("PASS");

    //Calling the diverChecker method for every single defined function
    //to check for divergence
    for(int i = 0; i < jstArr.size(); i++){
        forComp.clear();
        diverChecker(jstArr.get(0));
    }

  }

//The class funcObj was made in mind to use in navigating through the program
//block to go through all the function calls so that in the end it just stores
//all the tokens in the list which can then be evaluated using a stack.
  static class funcObj{
    Token t0;
    LinkedList<funcObj> bodyF = new LinkedList<funcObj>();

    funcObj() {}

    Token getToken(){
        return t0;
    }

    void setToken(Token t1){
        t0 = t1;
    }
  }

//Checks for circular calls in functions. If circular calls
//exit then print Divergence.
  public static void diverChecker(Token qwe){
    Token rty = qwe;
    forComp.add(rty);
    LinkedList<Token> ng = new LinkedList<Token>();
    ng = (LinkedList<Token>) diverMap.get(rty.image).clone();
    for(int i = 0; i < ng.size(); i++){
        if(forComp.contains(ng.get(i))){
        System.err.println("DIVERGENCE");
        System.exit(0);
        }else{
            diverChecker(ng.get(i));
        }
    }
  }

  final public void start() throws ParseException, ParseException {Token t1 ;
    Token t2 ;
    Token t3 ;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case KDEF:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(KDEF);
      jj_consume_token(SPACE);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MFUNC:{
        t1 = jj_consume_token(MFUNC);
//Storing the function name as a String if it isn't already stored.
                //If its already stored then printing the error on the screen.
                if(funcArr.contains(t1.image)){
                    System.out.println("FAIL");
                    System.out.println(t1.beginLine);
                    System.err.println("Function name reused");
                    System.exit(0);
                }else{
                    funcArr.add(t1.image);
                }
                //Storing the function name as a Token if it isn't already stored.
                //If its already stored then printing the error on the screen.
                if(jstArr.contains(t1)){
                    System.out.println("FAIL");
                    System.out.println(t1.beginLine);
                    System.err.println("Function name reused");
                    System.exit(0);
                }else{
                    jstArr.add(t1);
                }
        for_mainfunc();
        break;
        }
      case NFUNC:{
        t2 = jj_consume_token(NFUNC);
//Storing the function name as a string if it isn't already stored.
                //If its already stored then printing the error on the screen.
                if(funcArr.contains(t2.image)){
                    System.out.println("FAIL");
                    System.err.println(t2.beginLine);
                    System.err.println("Function name reused");
                    System.exit(0);
                }else{
                    funcArr.add(t2.image);
                }
                //Storing the function name as a Token if it isn't already stored.
                //If its already stored then printing the error on the screen.
                if(jstArr.contains(t2)){
                    System.out.println("FAIL");
                    System.out.println(t2.beginLine);
                    System.err.println("Function name reused");
                    System.exit(0);
                }else{
                    jstArr.add(t2);
                }
        for_normfunc();
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
//If the Main function is not present in the program block,
        //print the below error message.
        if(!mainf){
            System.out.println("FAIL");
            System.err.println("0");
            System.err.println("Main function not found");
            System.exit(0);
        }
        //If the function body consists of an undefined function,
        //print the following error message.
        for(int i = 0; i < bodyFuncArr.size(); i++){
            if(!funcArr.contains(bodyFuncArr.get(i))){
                System.out.println("FAIL");
                System.err.println("Undefined Function used in Function body");
                System.exit(0);
            }
        }
}

//Tells us how the tokens should appear once the parser reads the Main function.
  final public void for_mainfunc() throws ParseException {
//If this is the first occurence of the Main function,
        //set mainf to true or elseprint the error message below.
        if(mainf){
            System.out.println("FAIL");
            System.err.println("Main has already been defined");
            System.exit(0);
        }else{
            mainf = true;
        }
    jj_consume_token(SPACE);
    jj_consume_token(LCURL);
    jj_consume_token(SPACE);
    eval_body(null);
    jj_consume_token(SPACE);
//Values being added to the driverMap Hashmap
        diverList.addAll(tempDiver);
        tempDiver.clear();
        tempDiver = (LinkedList<Token>) diverList.clone();
        LinkedList<Token> vines = new LinkedList<Token>();
        vines = (LinkedList<Token>) tempDiver.clone();
        diverMap.put(funcArr.get(counter), vines);
        tempDiver.clear();
        diverList.clear();

        //Values being added to the tkntrack Hashmap
        tknStore.addAll(temper);
        temper = (LinkedList<Token>) tknStore.clone();
        LinkedList<funcObj> tt = new LinkedList<funcObj>();
        tt = (LinkedList<funcObj>) temper.clone();
        tknTrack.put(funcArr.get(counter), tt);
        temper.clear();
        tknStore.clear();
        counter++;
    jj_consume_token(RCURL);
    jj_consume_token(SPACE);
    jj_consume_token(SCOLN);
    jj_consume_token(EOL);
}

//Tells us how the Tokens should appear once the parsers reads the
//normal functions.
  final public void for_normfunc() throws ParseException {Token param;
    jj_consume_token(SPACE);
    param = jj_consume_token(PARAM);
    jj_consume_token(SPACE);
    jj_consume_token(LCURL);
    jj_consume_token(SPACE);
    eval_body(param);
    jj_consume_token(SPACE);
//Values being added to the driverMap Hashmap
        diverList.addAll(tempDiver);
        tempDiver.clear();
        tempDiver = (LinkedList<Token>) diverList.clone();
        LinkedList<Token> vines = new LinkedList<Token>();
        vines = (LinkedList<Token>) tempDiver.clone();
        diverMap.put(funcArr.get(counter), vines);
        tempDiver.clear();
        diverList.clear();

        //Values being added to the tknTrack Hashmap
        tknStore.addAll(temper);
        temper = (LinkedList<Token>) tknStore.clone();
        LinkedList<funcObj> tt = new LinkedList<funcObj>();
        tt = (LinkedList<funcObj>) temper.clone();
        tknTrack.put(funcArr.get(counter), tt);
        temper.clear();
        tknStore.clear();
        counter++;
    jj_consume_token(RCURL);
    jj_consume_token(SPACE);
    jj_consume_token(SCOLN);
    jj_consume_token(EOL);
}

//Specifies how the Tokens can appear inside the function body.
//Inside this all the operations of adding the function body
//to the lists which are in the end added to the Hashmaps occur.
  final public void eval_body(Token param) throws ParseException {Token number ;
Token func_name ;
Token op ;
Token parameter;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUM:{
      number = jj_consume_token(NUM);
temper.add(number);
      break;
      }
    case PARAM:{
      parameter = jj_consume_token(PARAM);
temper.add(parameter);
      break;
      }
    case NFUNC:{
      func_name = jj_consume_token(NFUNC);
temper.add(func_name);
            tempDiver.add(func_name);
            if(!bodyFuncArr.contains(func_name.image)){
                bodyFuncArr.add(func_name.image);
            }
      jj_consume_token(LBRAC);
diverList.addAll(tempDiver);
        tempDiver.clear();
        tknStore.addAll(temper);
        temper.clear();
      eval_body(param);
      jj_consume_token(RBRAC);
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MULT:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        op = jj_consume_token(PLUS);
temper.add(op);
        break;
        }
      case MULT:{
        op = jj_consume_token(MULT);
temper.add(op);
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NUM:{
        number = jj_consume_token(NUM);
temper.add(number);
        break;
        }
      case PARAM:{
        parameter = jj_consume_token(PARAM);
temper.add(parameter);
        break;
        }
      case NFUNC:{
        func_name = jj_consume_token(NFUNC);
temper.add(func_name);
                tempDiver.add(func_name);
                if(!bodyFuncArr.contains(func_name.image)){
                    bodyFuncArr.add(func_name.image);
                }
        jj_consume_token(LBRAC);
diverList.addAll(tempDiver);
            tempDiver.clear();
            tknStore.addAll(temper);
            temper.clear();
        eval_body(param);
        jj_consume_token(RBRAC);
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
}

  /** Generated Token Manager. */
  public AssignmentTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[6];
  static private int[] jj_la1_0;
  static {
	   jj_la1_init_0();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x80,0x1800,0x7000,0x6,0x6,0x7000,};
	}

  /** Constructor with InputStream. */
  public Assignment(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Assignment(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new AssignmentTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Assignment(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new AssignmentTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new AssignmentTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Assignment(AssignmentTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(AssignmentTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[15];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 6; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 15; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
